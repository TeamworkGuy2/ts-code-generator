"use strict";
var Q = require("q");
var fs = require("fs");
/**
 * @author TeamworkGuy2
 */
var TransformFile;
(function (TransformFile) {
    var MatchOperation;
    (function (MatchOperation) {
        MatchOperation[MatchOperation["REPLACE_LINES"] = 0] = "REPLACE_LINES";
        MatchOperation[MatchOperation["REPLACE_MATCHING_PORTION"] = 1] = "REPLACE_MATCHING_PORTION";
        MatchOperation[MatchOperation["DELETE_LINES"] = 2] = "DELETE_LINES";
        MatchOperation[MatchOperation["DELETE_MATCHING_PORTION"] = 3] = "DELETE_MATCHING_PORTION";
        MatchOperation[MatchOperation["RETURN_MATCHING_LINES"] = 4] = "RETURN_MATCHING_LINES";
        MatchOperation[MatchOperation["RETURN_MATCHING_PORTIONS"] = 5] = "RETURN_MATCHING_PORTIONS";
        MatchOperation[MatchOperation["PRINT_LINES"] = 6] = "PRINT_LINES";
    })(MatchOperation || (MatchOperation = {}));
    /** Split a file's contents into lines at either '\n' or '\r\n'
     * @param fileContent
     */
    function splitFileLines(fileContent) {
        var lines = fileContent.split(/\n|\r\n/);
        return lines;
    }
    TransformFile.splitFileLines = splitFileLines;
    /** Replace '\n' with '\r\n' and replace '\t' with four spaces '    '
     * @param text
     */
    function joinLinesForFile(text) {
        var res = text.replace(/\n/g, "\r\n").replace(/\t/g, "    ");
        return res;
    }
    TransformFile.joinLinesForFile = joinLinesForFile;
    /** Map a dictionary of variable names and strings/string arrays/replace text variables to a map of variable names and replace text variables
     * using a default 'MatchOperation' to create a replace text variable when a variable name maps to a string or string array
     */
    function mapVarsToOps(op, variableNamesToLines) {
        var variables = {};
        return Object.keys(variableNamesToLines).reduce(function (vars, k) {
            var varData = variableNamesToLines[k];
            var isStrOrStrAry = typeof varData === "string" || Array.isArray(varData);
            vars[k] = isStrOrStrAry ? { op: op, opParam: varData } : varData;
            return vars;
        }, variables);
    }
    TransformFile.mapVarsToOps = mapVarsToOps;
    /** Replace lines containing a variable with lines/strings from a map of variable names to string arrays
     * TODO: use StringTemplate v3/v4 to fill in template file
     *
     * @param startMarker: the start marker before all variable names, (for example '$' default for StringTemplate)
     * @param endMarker: the end marker after all variable names, (for example '$' default for StringTemplate)
     * @param transformations: a map of
     * Each transformation is applied to the lines generated by the previous transformation, transformations occur in the {@link Object#keys()} iteration order.
     * {MatchOperation} op: the operation to perform on each matching line, such as removing it from the array of returned lines,
     * replacing it from the {@code variableNamesToLines} or replacing just the matching variable name.
     * {String | String[]} opParam: the parameters to apply to the operation, for example {@link MatchOperation#REPLACE_LINES} takes
     * an array of lines and inserts them in place of each matching line, {@link MatchOperation#REPLACE_MATCHIN_PORTION} takes a single
     * string and replaces the matching portion of strings
     * variable names to operations and operation parameters to replace them with
     * @return an array of transformed strings
     */
    function transformLines(fileName, lines, startMarker, endMarker, transformations) {
        startMarker = (startMarker === undefined || startMarker === null) ? "" : startMarker;
        endMarker = (endMarker === undefined || endMarker === null) ? "" : endMarker;
        var origLines = lines;
        var newLines = null;
        var variableNames = Object.keys(transformations);
        var maxLineNumDigits = lines.length.toString().length;
        // if we are only printing matching lines, we don't need array for resulting lines
        if (variableNames != null && variableNames.filter(function (k) { return transformations[k].op === MatchOperation.PRINT_LINES; }).length === variableNames.length) {
            gutil.log("Matching lines in: " + fileName);
        }
        var returnNonMatching = true;
        // don't return non-matching strings if any of the transformation operations are 'return' operations
        if (variableNames != null && variableNames.filter(function (k) { return transformations[k].op === MatchOperation.RETURN_MATCHING_LINES || transformations[k].op === MatchOperation.RETURN_MATCHING_PORTIONS; }).length > 0) {
            returnNonMatching = false;
        }
        // variable-by-variable
        for (var ii = 0, sizeI = variableNames.length; ii < sizeI; ii++) {
            newLines = [];
            var variableName = variableNames[ii];
            var varFullName = startMarker + variableName + endMarker;
            var op = transformations[variableName].op;
            var opParam = transformations[variableName].opParam;
            var opParamIsAry = Array.isArray(opParam);
            // line-by-line
            for (var i = 0, size = lines.length; i < size; i++) {
                // if line contains variable name, replace line with variable replacement line
                if (lines[i].indexOf(varFullName) > -1) {
                    switch (op) {
                        case MatchOperation.DELETE_LINES:
                            break;
                        case MatchOperation.PRINT_LINES:
                            gutil.log(i + ". " + lines[i]);
                            break;
                        case MatchOperation.REPLACE_LINES:
                            if (opParamIsAry) {
                                Array.prototype.push.apply(newLines, opParam);
                            }
                            else {
                                newLines.push(opParam);
                            }
                            break;
                        case MatchOperation.DELETE_MATCHING_PORTION:
                            var resLine = lines[i].replace(varFullName, "");
                            newLines.push(resLine);
                            break;
                        case MatchOperation.REPLACE_MATCHING_PORTION:
                            if (opParamIsAry) {
                                var resLine = lines[i].replace(varFullName, opParam[0]);
                                newLines.push(resLine);
                                if (opParam.length > 1) {
                                    Array.prototype.push.apply(newLines, opParam.slice(1));
                                }
                            }
                            else {
                                var resLine = lines[i].replace(varFullName, opParam);
                                newLines.push(resLine);
                            }
                            break;
                        case MatchOperation.RETURN_MATCHING_PORTIONS:
                            var matchStr = varFullName;
                        case MatchOperation.RETURN_MATCHING_LINES:
                            var matchStr = lines[i];
                            newLines.push(matchStr);
                            break;
                        default:
                            newLines.push(lines[i]);
                            break;
                    }
                }
                else {
                    if (returnNonMatching) {
                        newLines.push(lines[i]);
                    }
                }
            }
            // apply the next transformation to the lines generated by the last transformation
            lines = newLines;
        }
        return newLines || [];
    }
    TransformFile.transformLines = transformLines;
    function transformFile(srcFile, startVarMark, endVarMark, transformations, doneCb) {
        fs.readFile(srcFile, function (err, f) {
            if (err) {
                gutil.log("error reading file '" + srcFile + "': " + err + "");
                return;
            }
            var fileLines = splitFileLines(f.toString());
            var lines = transformLines(srcFile, fileLines, startVarMark, endVarMark, transformations);
            doneCb(lines);
        });
    }
    TransformFile.transformFile = transformFile;
    function _transformFileToLines(matchOp, srcFile, startVarMark, endVarMark, variablesNamesToLines, doneCb) {
        fs.readFile(srcFile, function (err, f) {
            if (err) {
                gutil.log("error reading file '" + srcFile + "': " + err + ", continuing");
            }
            var srcLines = splitFileLines(f.toString());
            var resLines = transformLines(srcFile, srcLines, startVarMark, endVarMark, mapVarsToOps(matchOp, variablesNamesToLines));
            doneCb(srcLines, resLines);
        });
    }
    /** Transform a file's contents and return the resulting lines to a callback function
     */
    function transformFileToLines(matchOp, srcFile, startVarMark, endVarMark, variablesNamesToLines, doneCb) {
        _transformFileToLines(matchOp, srcFile, startVarMark, endVarMark, variablesNamesToLines, function transformFileToLinesCallback(srcLines, resLines) {
            doneCb(resLines);
        });
    }
    TransformFile.transformFileToLines = transformFileToLines;
    /** Transform a file's contents and write it to a destination file
     */
    function transformFileToFile(matchOp, srcFile, dstFile, compileTypeScript, startVarMark, endVarMark, variablesNamesToLines, doneCb, errorCb, postFileWritten) {
        _transformFileToLines(matchOp, srcFile, startVarMark, endVarMark, variablesNamesToLines, function transformFileToFileCallback(srcLines, resLines) {
            gutil.log("transforming template '" + srcFile + "' (" + srcLines.length + " src lines, " + resLines.length + " res lines)");
            writeSourceCodeFile(dstFile, resLines, doneCb, errorCb, postFileWritten);
        });
    }
    TransformFile.transformFileToFile = transformFileToFile;
    function writeSourceCodeFile(fileName, srcLines, doneCb, errorCb, postFileWritten) {
        var text = srcLines.join("\n");
        text = joinLinesForFile(text);
        fs.writeFile(fileName, text, function (writeErr) {
            if (writeErr) {
                gutil.log("error writing generated '" + fileName + "': " + writeErr);
                errorCb("error writing generated '" + fileName + "': " + writeErr);
                return;
            }
            if (postFileWritten) {
                postFileWritten(fileName, function () {
                    doneCb("'" + fileName + "' " + srcLines.length + " lines");
                }, function (compileErr) {
                    doneCb("'" + fileName + "' " + srcLines.length + " lines");
                    gutil.log("error writing file '" + fileName + "': " + compileErr);
                });
            }
            else {
                doneCb("'" + fileName + "' " + srcLines.length + " lines");
            }
        });
    }
    TransformFile.writeSourceCodeFile = writeSourceCodeFile;
    /** Transform a file containing template variables
     * @param srcFile: the source file containing text to read
     * @param dstFile: the destination file to write the transformed text to
     * @param variablesNamesToLines: associates template variable names with the text to insert in their place
     * @param postFileWritten: a callback to call after writing the destination file
     * @param successMsg: a success message to pass to the resolved returned promise
     */
    function convertTemplateFile(srcFile, dstFile, variablesNamesToLines, postFileWritten, successMsg, delimiterStart, delimiterEnd) {
        if (delimiterStart === void 0) { delimiterStart = "$"; }
        if (delimiterEnd === void 0) { delimiterEnd = "$"; }
        var dfd = Q.defer();
        transformFileToFile(MatchOperation.REPLACE_MATCHING_PORTION, srcFile, dstFile, true, delimiterStart, delimiterEnd, variablesNamesToLines, function (msg) {
            dfd.resolve((successMsg ? successMsg + ": " : "") + msg);
        }, function (err) {
            dfd.reject(err);
        }, postFileWritten);
        return dfd.promise;
    }
    TransformFile.convertTemplateFile = convertTemplateFile;
})(TransformFile || (TransformFile = {}));
module.exports = TransformFile;
